<%= csrf_meta_tags %>

<header class="header">
  <div class="logo">
    <div class="logo-icon">üêò</div>
    <div class="logo-text">
      <h1>PgReports</h1>
      <span>PostgreSQL Analysis Dashboard</span>
    </div>
  </div>

  <div class="header-actions">
    <% if @pg_stat_status[:ready] %>
      <button class="btn btn-small btn-muted" onclick="showResetConfirmModal()" id="reset-btn">
        üóëÔ∏è Reset Statistics
      </button>
    <% else %>
      <button class="btn btn-small btn-primary" onclick="enablePgStatStatements(this)" id="enable-btn">
        ‚ö° Create Extension
      </button>
      <button class="btn-info" onclick="showPgStatInfo()">?</button>
    <% end %>
    <div class="header-badge" id="pg-stat-badge">
      <% if @pg_stat_status[:ready] %>
        <span class="badge-dot"></span>
        <span>pg_stat_statements ready</span>
      <% elsif @pg_stat_status[:extension_installed] %>
        <span class="badge-dot warning"></span>
        <span>Extension installed, not preloaded</span>
      <% elsif @pg_stat_status[:preloaded] %>
        <span class="badge-dot warning"></span>
        <span>Preloaded, extension not created</span>
      <% else %>
        <span class="badge-dot error"></span>
        <span>Not configured</span>
      <% end %>
    </div>
  </div>
</header>

<!-- pg_stat_statements info modal -->
<div id="pg-stat-modal" class="modal" style="display: none;">
  <div class="modal-content">
    <div class="modal-header">
      <h3>Enable pg_stat_statements</h3>
      <button class="modal-close" onclick="closePgStatModal()">√ó</button>
    </div>
    <div class="modal-body">
      <p>To enable pg_stat_statements, follow these steps:</p>
      <ol>
        <li>
          <strong>Edit postgresql.conf:</strong>
          <pre>shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.track = all</pre>
        </li>
        <li>
          <strong>Restart PostgreSQL:</strong>
          <pre>sudo systemctl restart postgresql</pre>
        </li>
        <li>
          <strong>Create extension:</strong>
          <pre>CREATE EXTENSION IF NOT EXISTS pg_stat_statements;</pre>
          <p>Or click "Enable" button after restart.</p>
        </li>
      </ol>
    </div>
  </div>
</div>

<!-- Reset statistics confirmation modal -->
<div id="reset-confirm-modal" class="modal" style="display: none;">
  <div class="modal-content modal-small">
    <div class="modal-header modal-header-danger">
      <h3>‚ö†Ô∏è Reset Statistics</h3>
      <button class="modal-close" onclick="closeResetConfirmModal()">√ó</button>
    </div>
    <div class="modal-body">
      <p class="warning-text">Are you sure you want to reset pg_stat_statements statistics?</p>
      <p class="warning-subtext">This action will clear all collected query statistics and cannot be undone.</p>
      <div class="modal-actions">
        <button class="btn btn-secondary" onclick="closeResetConfirmModal()">Cancel</button>
        <button class="btn btn-danger" onclick="resetStatistics()" id="confirm-reset-btn">Yes, Reset</button>
      </div>
    </div>
  </div>
</div>

<!-- Live Monitoring Panel -->
<div id="live-monitoring" class="live-monitoring-panel" style="display: none;">
  <div class="live-monitoring-header">
    <div class="live-monitoring-title">
      <span class="live-indicator"></span>
      <span>Live Monitoring</span>
      <span class="database-badge">
        Database: <strong><%= @current_database %></strong>
      </span>
    </div>
    <div class="live-monitoring-controls">
      <span class="live-monitoring-interval">Updates every 5s</span>
      <button class="btn-toggle-live" onclick="toggleLiveMonitoring()" title="Toggle live monitoring">
        <span id="toggle-icon">‚è∏</span>
      </button>
    </div>
  </div>

  <div class="live-metrics-grid">
    <!-- Connections -->
    <div class="live-metric-card" data-metric="connections">
      <div class="metric-header">
        <span class="metric-icon" style="background: rgba(107, 159, 232, 0.12); color: var(--accent-blue);">üîó</span>
        <span class="metric-name">Connections</span>
      </div>
      <div class="metric-body">
        <div class="metric-value">
          <span id="metric-connections-value">-</span>
          <span class="metric-unit">/ <span id="metric-connections-max">-</span></span>
        </div>
        <div class="metric-detail">
          <span id="metric-connections-pct">-</span>% used
        </div>
        <div class="metric-sparkline">
          <svg id="sparkline-connections" viewBox="0 0 100 30" preserveAspectRatio="none"></svg>
        </div>
      </div>
      <div class="metric-status" id="status-connections"></div>
    </div>

    <!-- TPS -->
    <div class="live-metric-card" data-metric="tps">
      <div class="metric-header">
        <span class="metric-icon" style="background: rgba(95, 184, 154, 0.12); color: var(--accent-green);">‚ö°</span>
        <span class="metric-name">TPS</span>
      </div>
      <div class="metric-body">
        <div class="metric-value">
          <span id="metric-tps-value">-</span>
          <span class="metric-unit">tx/s</span>
        </div>
        <div class="metric-detail">
          commit: <span id="metric-tps-commit">-</span> / rollback: <span id="metric-tps-rollback">-</span>
        </div>
        <div class="metric-sparkline">
          <svg id="sparkline-tps" viewBox="0 0 100 30" preserveAspectRatio="none"></svg>
        </div>
      </div>
      <div class="metric-status" id="status-tps"></div>
    </div>

    <!-- Cache Hit Ratio -->
    <div class="live-metric-card" data-metric="cache">
      <div class="metric-header">
        <span class="metric-icon" style="background: rgba(157, 140, 214, 0.12); color: var(--accent-purple);">üíæ</span>
        <span class="metric-name">Cache Hit</span>
      </div>
      <div class="metric-body">
        <div class="metric-value">
          <span id="metric-cache-value">-</span>
          <span class="metric-unit">%</span>
        </div>
        <div class="metric-detail">heap blocks from cache</div>
        <div class="metric-sparkline">
          <svg id="sparkline-cache" viewBox="0 0 100 30" preserveAspectRatio="none"></svg>
        </div>
      </div>
      <div class="metric-status" id="status-cache"></div>
    </div>

    <!-- Long Running Queries -->
    <div class="live-metric-card" data-metric="longrunning">
      <div class="metric-header">
        <span class="metric-icon" style="background: rgba(212, 160, 86, 0.12); color: var(--accent-amber);">üê¢</span>
        <span class="metric-name">Long Queries</span>
      </div>
      <div class="metric-body">
        <div class="metric-value">
          <span id="metric-longrunning-value">-</span>
          <span class="metric-unit">queries</span>
        </div>
        <div class="metric-detail">&gt; 60s runtime</div>
        <div class="metric-sparkline">
          <svg id="sparkline-longrunning" viewBox="0 0 100 30" preserveAspectRatio="none"></svg>
        </div>
      </div>
      <div class="metric-status" id="status-longrunning"></div>
    </div>

    <!-- Blocked Queries -->
    <div class="live-metric-card" data-metric="blocked">
      <div class="metric-header">
        <span class="metric-icon" style="background: rgba(217, 112, 132, 0.12); color: var(--accent-rose);">üîí</span>
        <span class="metric-name">Blocked</span>
      </div>
      <div class="metric-body">
        <div class="metric-value">
          <span id="metric-blocked-value">-</span>
          <span class="metric-unit">processes</span>
        </div>
        <div class="metric-detail">waiting for locks</div>
        <div class="metric-sparkline">
          <svg id="sparkline-blocked" viewBox="0 0 100 30" preserveAspectRatio="none"></svg>
        </div>
      </div>
      <div class="metric-status" id="status-blocked"></div>
    </div>
  </div>
</div>

<!-- Query Monitoring Panel -->
<div id="query-monitoring" class="query-monitoring-panel" style="display: none;">
  <div class="query-monitoring-header">
    <div class="query-monitoring-title">
      <span class="monitoring-indicator" id="monitor-indicator"></span>
      <span>SQL Query Monitor</span>
      <span class="session-badge" id="session-badge" style="display: none;">
        Session: <strong id="session-id"></strong>
      </span>
    </div>
    <div class="query-monitoring-controls">
      <button class="btn btn-small btn-primary" onclick="startQueryMonitoring(this)" id="start-monitor-btn">
        ‚ñ∂ Start Monitoring
      </button>
      <button class="btn btn-small btn-danger" onclick="stopQueryMonitoring(this)" id="stop-monitor-btn" style="display: none;">
        ‚èπ Stop Monitoring
      </button>
      <div class="download-dropdown" id="monitor-download-dropdown" style="display: none;">
        <button class="btn btn-small btn-secondary" onclick="toggleMonitorDownloadMenu(event)">
          üì• Download
        </button>
        <div class="download-menu" id="monitor-download-menu" style="display: none;">
          <a href="#" onclick="downloadQueryMonitor('txt'); return false;">üìÑ Text (.txt)</a>
          <a href="#" onclick="downloadQueryMonitor('csv'); return false;">üìä CSV (.csv)</a>
          <a href="#" onclick="downloadQueryMonitor('json'); return false;">üìã JSON (.json)</a>
        </div>
      </div>
      <span class="query-monitoring-count">
        Queries: <strong id="query-count">0</strong>
      </span>
    </div>
  </div>

  <div class="query-feed" id="query-feed">
    <div class="query-feed-empty">
      Click "Start Monitoring" to begin capturing SQL queries
    </div>
  </div>
</div>

<div class="categories-grid">
  <% @categories.each do |category_key, category| %>
    <div class="category-card<%= ' disabled' if category_key == :queries && !@pg_stat_status[:ready] %>">
      <% if category_key == :queries && !@pg_stat_status[:ready] %>
        <div class="category-warning">
          <span>üîí</span> Requires pg_stat_statements
        </div>
      <% end %>
      <div class="category-header">
        <div class="category-icon" style="background: <%= category[:color] %>20; color: <%= category[:color] %>;">
          <%= category[:icon] %>
        </div>
        <span class="category-title"><%= category[:name] %></span>
        <span class="category-count"><%= category[:reports].size %> reports</span>
      </div>

      <div class="reports-list">
        <% category[:reports].each do |report_key, report| %>
          <% if category_key == :queries && !@pg_stat_status[:ready] %>
            <div class="report-link disabled">
              <div class="report-link-info">
                <span class="report-link-name"><%= report[:name] %></span>
                <span class="report-link-desc"><%= report[:description] %></span>
              </div>
              <span class="lock">üîí</span>
            </div>
          <% else %>
            <%= link_to report_path(category: category_key, report: report_key), class: "report-link" do %>
              <div class="report-link-info">
                <span class="report-link-name"><%= report[:name] %></span>
                <span class="report-link-desc"><%= report[:description] %></span>
              </div>
              <span class="arrow">‚Üí</span>
            <% end %>
          <% end %>
        <% end %>
      </div>
    </div>
  <% end %>
</div>

<style>
  .header-actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .btn.btn-small {
    padding: 0.5rem 1rem;
    font-size: 0.8rem;
  }

  .btn-info {
    width: 24px;
    height: 24px;
    padding: 0;
    background: var(--bg-tertiary);
    color: var(--text-muted);
    border: 1px solid var(--border-color);
    border-radius: 50%;
    font-size: 0.8rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }
  .btn-info:hover {
    background: var(--accent-purple);
    color: white;
    border-color: var(--accent-purple);
  }

  .btn.btn-danger {
    background: var(--accent-rose);
    border-color: var(--accent-rose);
  }
  .btn.btn-danger:hover {
    background: #c45a6e;
    border-color: #c45a6e;
  }

  .btn.btn-secondary {
    background: var(--bg-tertiary);
    border-color: var(--border-color);
    color: var(--text-secondary);
  }
  .btn.btn-secondary:hover {
    background: var(--bg-card);
    color: var(--text-primary);
  }

  .btn.btn-muted {
    background: var(--bg-tertiary);
    border-color: var(--accent-rose);
    color: var(--text-secondary);
  }
  .btn.btn-muted:hover {
    background: var(--bg-card);
    color: var(--text-primary);
  }

  .badge-dot.error { background: var(--accent-rose); }

  .category-card.disabled {
    opacity: 0.7;
  }

  .category-warning {
    padding: 0.625rem 1rem;
    margin: -1.5rem -1.5rem 1rem -1.5rem;
    background: rgba(245, 158, 11, 0.1);
    border-bottom: 1px solid rgba(245, 158, 11, 0.2);
    border-radius: 16px 16px 0 0;
    color: var(--accent-amber);
    font-size: 0.8rem;
    font-weight: 500;
    text-align: center;
  }

  .report-link.disabled {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.75rem 1rem;
    background: var(--bg-tertiary);
    border: 1px solid transparent;
    border-radius: 10px;
    color: var(--text-muted);
    font-size: 0.9rem;
    cursor: not-allowed;
  }

  .report-link .lock {
    font-size: 0.75rem;
    opacity: 0.5;
  }

  .report-link-info {
    display: flex;
    flex-direction: column;
    gap: 0.125rem;
    flex: 1;
    min-width: 0;
  }

  .report-link-name {
    font-weight: 500;
    color: inherit;
  }

  .report-link-desc {
    font-size: 0.75rem;
    color: var(--text-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .report-link:hover .report-link-desc {
    color: var(--text-secondary);
  }

  /* Modal */
  .modal {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    backdrop-filter: blur(4px);
  }

  .modal-content {
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow: auto;
  }

  .modal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 1.25rem 1.5rem;
    border-bottom: 1px solid var(--border-color);
  }

  .modal-header h3 {
    font-size: 1.125rem;
    font-weight: 600;
  }

  .modal-close {
    width: 32px;
    height: 32px;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    color: var(--text-muted);
    font-size: 1.25rem;
    cursor: pointer;
    transition: all 0.15s;
  }

  .modal-close:hover {
    background: var(--accent-rose);
    border-color: var(--accent-rose);
    color: white;
  }

  .modal-body {
    padding: 1.5rem;
  }

  .modal-body p {
    color: var(--text-secondary);
    margin-bottom: 1rem;
  }

  .modal-body ol {
    list-style-position: inside;
    color: var(--text-secondary);
  }

  .modal-body li {
    margin-bottom: 1.25rem;
  }

  .modal-body strong {
    color: var(--text-primary);
  }

  .modal-body pre {
    margin-top: 0.5rem;
    padding: 1rem;
    background: var(--bg-primary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8rem;
    color: var(--accent-green);
    overflow-x: auto;
  }

  .modal-small {
    max-width: 420px;
  }

  .modal-header-danger {
    background: rgba(244, 63, 94, 0.1);
    border-bottom-color: rgba(244, 63, 94, 0.2);
  }

  .modal-header-danger h3 {
    color: var(--accent-rose);
  }

  .warning-text {
    font-size: 1rem;
    font-weight: 500;
    color: var(--text-primary) !important;
    margin-bottom: 0.5rem !important;
  }

  .warning-subtext {
    font-size: 0.875rem;
    color: var(--text-muted) !important;
    margin-bottom: 1.5rem !important;
  }

  .modal-actions {
    display: flex;
    gap: 0.75rem;
    justify-content: flex-end;
  }

  .modal-actions .btn {
    padding: 0.625rem 1.25rem;
    font-size: 0.875rem;
  }

  /* Live Monitoring Panel */
  .live-monitoring-panel {
    margin-bottom: 2rem;
    background: var(--bg-card);
    border: 1px solid var(--border-color);
    border-radius: 16px;
    padding: 1.25rem 1.5rem;
  }

  .live-monitoring-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 1.25rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border-color);
  }

  .live-monitoring-title {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-weight: 600;
    font-size: 1rem;
  }

  .database-badge {
    margin-left: 0.5rem;
    padding: 0.375rem 0.75rem;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--text-secondary);
  }

  .database-badge strong {
    color: var(--text-primary);
    font-weight: 600;
  }

  .live-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--accent-green);
    animation: pulse 2s infinite;
  }

  .live-indicator.paused {
    background: var(--text-muted);
    animation: none;
  }

  .live-monitoring-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .live-monitoring-interval {
    font-size: 0.75rem;
    color: var(--text-muted);
  }

  .btn-toggle-live {
    width: 32px;
    height: 32px;
    padding: 0;
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    color: var(--text-muted);
    font-size: 0.875rem;
    cursor: pointer;
    transition: all 0.15s;
  }

  .btn-toggle-live:hover {
    background: var(--bg-secondary);
    color: var(--text-primary);
  }

  /* Metrics Grid */
  .live-metrics-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 1rem;
  }

  @media (max-width: 1200px) {
    .live-metrics-grid {
      grid-template-columns: repeat(3, 1fr);
    }
  }

  @media (max-width: 768px) {
    .live-metrics-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 500px) {
    .live-metrics-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Metric Card */
  .live-metric-card {
    background: var(--bg-tertiary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 1rem;
    position: relative;
    transition: all 0.2s;
  }

  .live-metric-card:hover {
    border-color: var(--accent-purple);
  }

  .live-metric-card.status-ok {
    border-left: 3px solid var(--accent-green);
  }

  .live-metric-card.status-warning {
    border-left: 3px solid var(--accent-amber);
  }

  .live-metric-card.status-critical {
    border-left: 3px solid var(--accent-rose);
  }

  .metric-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.75rem;
  }

  .metric-icon {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.875rem;
  }

  .metric-name {
    font-size: 0.8rem;
    font-weight: 500;
    color: var(--text-secondary);
  }

  .metric-body {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .metric-value {
    display: flex;
    align-items: baseline;
    gap: 0.25rem;
  }

  .metric-value span:first-child {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text-primary);
    line-height: 1;
  }

  .metric-unit {
    font-size: 0.75rem;
    color: var(--text-muted);
  }

  .metric-detail {
    font-size: 0.7rem;
    color: var(--text-muted);
  }

  /* Sparkline */
  .metric-sparkline {
    height: 30px;
    margin-top: 0.5rem;
  }

  .metric-sparkline svg {
    width: 100%;
    height: 100%;
  }

  /* Status indicator */
  .metric-status {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    width: 6px;
    height: 6px;
    border-radius: 50%;
  }

  .metric-status.ok { background: var(--accent-green); }
  .metric-status.warning { background: var(--accent-amber); }
  .metric-status.critical { background: var(--accent-rose); }
</style>

<script>
  function showPgStatInfo() {
    document.getElementById('pg-stat-modal').style.display = 'flex';
  }

  function closePgStatModal() {
    document.getElementById('pg-stat-modal').style.display = 'none';
  }

  // Close modal on backdrop click
  document.getElementById('pg-stat-modal')?.addEventListener('click', function(e) {
    if (e.target === this) closePgStatModal();
  });

  function showResetConfirmModal() {
    document.getElementById('reset-confirm-modal').style.display = 'flex';
  }

  function closeResetConfirmModal() {
    document.getElementById('reset-confirm-modal').style.display = 'none';
  }

  // Close reset modal on backdrop click
  document.getElementById('reset-confirm-modal')?.addEventListener('click', function(e) {
    if (e.target === this) closeResetConfirmModal();
  });

  async function resetStatistics() {
    const button = document.getElementById('confirm-reset-btn');
    button.disabled = true;
    button.innerHTML = '<span class="spinner" style="width:14px;height:14px;border-width:2px;display:inline-block;vertical-align:middle;margin-right:6px;"></span> Resetting...';

    try {
      const response = await fetch(`${pgReportsRoot}/reset_statistics`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content || ''
        }
      });

      const data = await response.json();

      if (data.success) {
        closeResetConfirmModal();
        showToast(data.message);
      } else {
        showToast(data.error || 'Failed to reset statistics', 'error');
        button.disabled = false;
        button.innerHTML = 'Yes, Reset';
      }
    } catch (error) {
      showToast('Network error: ' + error.message, 'error');
      button.disabled = false;
      button.innerHTML = 'Yes, Reset';
    }
  }

  async function enablePgStatStatements(button) {
    button.disabled = true;
    button.innerHTML = '<span class="spinner" style="width:14px;height:14px;border-width:2px;display:inline-block;vertical-align:middle;margin-right:6px;"></span> Creating...';

    try {
      const response = await fetch(`${pgReportsRoot}/enable_pg_stat_statements`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content || ''
        }
      });

      const data = await response.json();

      if (data.success) {
        showToast(data.message);
        // Reload page to update status
        setTimeout(() => location.reload(), 1000);
      } else {
        showToast(data.message, 'error');
        if (data.requires_restart) {
          showPgStatInfo();
        }
        button.disabled = false;
        button.innerHTML = '‚ö° Create Extension';
      }
    } catch (error) {
      showToast('Network error: ' + error.message, 'error');
      button.disabled = false;
      button.innerHTML = '‚ö° Create Extension';
    }
  }

  // ============================================
  // Live Monitoring
  // ============================================

  const LIVE_CONFIG = {
    pollInterval: 5000,
    historyLength: 30,
    thresholds: {
      connections: { warning: 70, critical: 90 },
      tps: { warning: null, critical: null },
      cache: { warning: 95, critical: 90 },
      longrunning: { warning: 1, critical: 5 },
      blocked: { warning: 1, critical: 3 }
    }
  };

  let liveMonitoringEnabled = true;
  let pollTimer = null;
  let previousMetrics = null;
  const metricsHistory = {
    connections: [],
    tps: [],
    cache: [],
    longrunning: [],
    blocked: []
  };

  function initLiveMonitoring() {
    const panel = document.getElementById('live-monitoring');
    if (!panel) return;

    panel.style.display = 'block';

    const savedState = localStorage.getItem('pgReportsLiveMonitoring');
    if (savedState === 'disabled') {
      liveMonitoringEnabled = false;
      updateToggleUI();
    }

    if (liveMonitoringEnabled) {
      fetchLiveMetrics();
      startPolling();
    }
  }

  function startPolling() {
    if (pollTimer) clearInterval(pollTimer);
    pollTimer = setInterval(fetchLiveMetrics, LIVE_CONFIG.pollInterval);
  }

  function stopPolling() {
    if (pollTimer) {
      clearInterval(pollTimer);
      pollTimer = null;
    }
  }

  function toggleLiveMonitoring() {
    liveMonitoringEnabled = !liveMonitoringEnabled;
    localStorage.setItem('pgReportsLiveMonitoring', liveMonitoringEnabled ? 'enabled' : 'disabled');
    updateToggleUI();

    if (liveMonitoringEnabled) {
      fetchLiveMetrics();
      startPolling();
    } else {
      stopPolling();
    }
  }

  function updateToggleUI() {
    const icon = document.getElementById('toggle-icon');
    const indicator = document.querySelector('.live-indicator');

    if (liveMonitoringEnabled) {
      icon.textContent = '‚è∏';
      indicator.classList.remove('paused');
    } else {
      icon.textContent = '‚ñ∂';
      indicator.classList.add('paused');
    }
  }

  async function fetchLiveMetrics() {
    try {
      const response = await fetch(`${pgReportsRoot}/live_metrics`);
      const data = await response.json();

      if (data.success) {
        updateMetricsDisplay(data.metrics);
      }
    } catch (error) {
      console.error('Failed to fetch live metrics:', error);
    }
  }

  function updateMetricsDisplay(metrics) {
    let tps = 0;
    if (previousMetrics) {
      const timeDelta = metrics.timestamp - previousMetrics.timestamp;
      if (timeDelta > 0) {
        const txDelta = metrics.transactions.total - previousMetrics.transactions.total;
        tps = Math.max(0, Math.round(txDelta / timeDelta));
      }
    }

    document.getElementById('metric-connections-value').textContent = metrics.connections.total;
    document.getElementById('metric-connections-max').textContent = metrics.connections.max;
    document.getElementById('metric-connections-pct').textContent = metrics.connections.percent.toFixed(1);

    document.getElementById('metric-tps-value').textContent = tps;
    document.getElementById('metric-tps-commit').textContent = formatNumber(metrics.transactions.commit);
    document.getElementById('metric-tps-rollback').textContent = formatNumber(metrics.transactions.rollback);

    document.getElementById('metric-cache-value').textContent = metrics.cache_hit_ratio.toFixed(2);

    document.getElementById('metric-longrunning-value').textContent = metrics.long_running_count;

    document.getElementById('metric-blocked-value').textContent = metrics.blocked_count;

    addToHistory('connections', metrics.connections.percent);
    addToHistory('tps', tps);
    addToHistory('cache', metrics.cache_hit_ratio);
    addToHistory('longrunning', metrics.long_running_count);
    addToHistory('blocked', metrics.blocked_count);

    renderSparkline('connections', metricsHistory.connections, 'var(--accent-blue)');
    renderSparkline('tps', metricsHistory.tps, 'var(--accent-green)');
    renderSparkline('cache', metricsHistory.cache, 'var(--accent-purple)');
    renderSparkline('longrunning', metricsHistory.longrunning, 'var(--accent-amber)');
    renderSparkline('blocked', metricsHistory.blocked, 'var(--accent-rose)');

    updateStatus('connections', metrics.connections.percent, 'higher');
    updateStatus('tps', tps, null);
    updateStatus('cache', metrics.cache_hit_ratio, 'lower');
    updateStatus('longrunning', metrics.long_running_count, 'higher');
    updateStatus('blocked', metrics.blocked_count, 'higher');

    previousMetrics = metrics;
  }

  function addToHistory(metric, value) {
    metricsHistory[metric].push(value);
    if (metricsHistory[metric].length > LIVE_CONFIG.historyLength) {
      metricsHistory[metric].shift();
    }
  }

  function formatNumber(num) {
    if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
    if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
    return num.toString();
  }

  function renderSparkline(metric, data, color) {
    const svg = document.getElementById(`sparkline-${metric}`);
    if (!svg || data.length < 2) return;

    svg.innerHTML = '';

    const width = 100;
    const height = 30;
    const padding = 2;

    const min = Math.min(...data);
    const max = Math.max(...data);
    const range = max - min || 1;

    const points = data.map((value, index) => {
      const x = padding + (index / (data.length - 1)) * (width - 2 * padding);
      const y = height - padding - ((value - min) / range) * (height - 2 * padding);
      return { x, y };
    });

    const pathD = points.map((p, i) => (i === 0 ? `M ${p.x} ${p.y}` : `L ${p.x} ${p.y}`)).join(' ');

    const areaD = pathD +
      ` L ${points[points.length - 1].x} ${height - padding}` +
      ` L ${points[0].x} ${height - padding} Z`;

    const area = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    area.setAttribute('d', areaD);
    area.setAttribute('fill', color);
    area.setAttribute('opacity', '0.15');
    svg.appendChild(area);

    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathD);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width', '1.5');
    path.setAttribute('stroke-linecap', 'round');
    path.setAttribute('stroke-linejoin', 'round');
    svg.appendChild(path);
  }

  function updateStatus(metric, value, badDirection) {
    const card = document.querySelector(`[data-metric="${metric}"]`);
    const statusDot = document.getElementById(`status-${metric}`);
    if (!card || !statusDot) return;

    const thresholds = LIVE_CONFIG.thresholds[metric];
    if (!thresholds.warning && !thresholds.critical) {
      card.className = 'live-metric-card status-ok';
      statusDot.className = 'metric-status ok';
      return;
    }

    let status = 'ok';

    if (badDirection === 'higher') {
      if (value >= thresholds.critical) status = 'critical';
      else if (value >= thresholds.warning) status = 'warning';
    } else if (badDirection === 'lower') {
      if (value <= thresholds.critical) status = 'critical';
      else if (value <= thresholds.warning) status = 'warning';
    }

    card.className = `live-metric-card status-${status}`;
    statusDot.className = `metric-status ${status}`;
  }

  document.addEventListener('DOMContentLoaded', initLiveMonitoring);
  window.addEventListener('beforeunload', stopPolling);

  // ============================================
  // Query Monitoring
  // ============================================

  const QUERY_MONITOR_CONFIG = {
    pollInterval: 2000,
    maxQueries: 50
  };

  let queryMonitorEnabled = false;
  let queryMonitorPollTimer = null;
  let currentSessionId = null;
  let queryCount = 0;

  function initQueryMonitoring() {
    const panel = document.getElementById('query-monitoring');
    if (!panel) return;

    // Check initial status
    checkQueryMonitorStatus();
  }

  async function checkQueryMonitorStatus() {
    try {
      const response = await fetch(`${pgReportsRoot}/query_monitor/status`);
      const data = await response.json();

      if (data.success && data.enabled) {
        queryMonitorEnabled = true;
        currentSessionId = data.session_id;
        queryCount = data.query_count;
        updateQueryMonitorUI(true);
        startQueryMonitorPolling();
      } else {
        // Monitoring not active - load history from log file
        queryMonitorEnabled = false;
        await loadQueryHistory();
        updateQueryMonitorUI(false);
      }
    } catch (error) {
      console.error('Failed to check query monitor status:', error);
      // Show panel anyway even if status check fails
      updateQueryMonitorUI(false);
    }
  }

  async function loadQueryHistory() {
    try {
      const response = await fetch(
        `${pgReportsRoot}/query_monitor/history?limit=${QUERY_MONITOR_CONFIG.maxQueries}`
      );
      const data = await response.json();

      if (data.success && data.queries && data.queries.length > 0) {
        renderQueryFeed(data.queries);
      }
    } catch (error) {
      console.error('Failed to load query history:', error);
    }
  }

  async function loadSessionFromLog(sessionId) {
    try {
      const response = await fetch(
        `${pgReportsRoot}/query_monitor/history?session_id=${sessionId}&limit=${QUERY_MONITOR_CONFIG.maxQueries}`
      );
      const data = await response.json();

      if (data.success && data.queries && data.queries.length > 0) {
        renderQueryFeed(data.queries);
      }
    } catch (error) {
      console.error('Failed to load session from log:', error);
    }
  }

  async function startQueryMonitoring(button) {
    button.disabled = true;
    button.innerHTML = '<span class="spinner"></span> Starting...';

    try {
      const response = await fetch(`${pgReportsRoot}/query_monitor/start`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content || ''
        }
      });

      const data = await response.json();

      if (data.success) {
        queryMonitorEnabled = true;
        currentSessionId = data.session_id;
        updateQueryMonitorUI(true);
        startQueryMonitorPolling();
        showToast(data.message);
      } else {
        showToast(data.message || 'Failed to start monitoring', 'error');
        button.disabled = false;
        button.innerHTML = '‚ñ∂ Start Monitoring';
      }
    } catch (error) {
      showToast('Network error: ' + error.message, 'error');
      button.disabled = false;
      button.innerHTML = '‚ñ∂ Start Monitoring';
    }
  }

  async function stopQueryMonitoring(button) {
    button.disabled = true;
    button.innerHTML = '<span class="spinner"></span> Stopping...';

    try {
      const response = await fetch(`${pgReportsRoot}/query_monitor/stop`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content || ''
        }
      });

      const data = await response.json();

      if (data.success) {
        queryMonitorEnabled = false;
        const stoppedSessionId = data.session_id || currentSessionId;
        currentSessionId = null;
        stopQueryMonitorPolling();

        // Load complete session data from log file
        if (stoppedSessionId) {
          await loadSessionFromLog(stoppedSessionId);
        }

        updateQueryMonitorUI(false);
        showToast(data.message);
      } else {
        showToast(data.message || 'Failed to stop monitoring', 'error');
        button.disabled = false;
        button.innerHTML = '‚èπ Stop Monitoring';
      }
    } catch (error) {
      showToast('Network error: ' + error.message, 'error');
      button.disabled = false;
      button.innerHTML = '‚èπ Stop Monitoring';
    }
  }

  function updateQueryMonitorUI(enabled) {
    const panel = document.getElementById('query-monitoring');
    const indicator = document.getElementById('monitor-indicator');
    const startBtn = document.getElementById('start-monitor-btn');
    const stopBtn = document.getElementById('stop-monitor-btn');
    const sessionBadge = document.getElementById('session-badge');
    const sessionIdEl = document.getElementById('session-id');
    const downloadDropdown = document.getElementById('monitor-download-dropdown');
    const feed = document.getElementById('query-feed');

    panel.style.display = 'block';

    if (enabled) {
      indicator.classList.add('active');
      startBtn.style.display = 'none';
      stopBtn.style.display = 'inline-block';
      stopBtn.disabled = false;
      stopBtn.innerHTML = '‚èπ Stop Monitoring';
      sessionBadge.style.display = 'inline-block';
      sessionIdEl.textContent = currentSessionId ? currentSessionId.substring(0, 8) : '';
      downloadDropdown.style.display = 'inline-block';
    } else {
      indicator.classList.remove('active');
      startBtn.style.display = 'inline-block';
      startBtn.disabled = false;
      startBtn.innerHTML = '‚ñ∂ Start Monitoring';
      stopBtn.style.display = 'none';
      sessionBadge.style.display = 'none';

      // Keep results visible after stopping, only hide download if no queries
      const hasQueries = queryCount > 0;
      downloadDropdown.style.display = hasQueries ? 'inline-block' : 'none';

      // Only clear feed if no queries captured
      if (!hasQueries) {
        feed.innerHTML = '<div class="query-feed-empty">Click "Start Monitoring" to begin capturing SQL queries</div>';
      }
    }
  }

  function toggleMonitorDownloadMenu(event) {
    event.stopPropagation();
    const menu = document.getElementById('monitor-download-menu');
    menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
  }

  function downloadQueryMonitor(format) {
    // Hide dropdown menu
    document.getElementById('monitor-download-menu').style.display = 'none';

    // Build download URL
    const url = `${pgReportsRoot}/query_monitor/download?format=${format}`;

    // Use hidden iframe to download without page reload
    let iframe = document.getElementById('download-iframe');
    if (!iframe) {
      iframe = document.createElement('iframe');
      iframe.id = 'download-iframe';
      iframe.style.display = 'none';
      document.body.appendChild(iframe);
    }
    iframe.src = url;
  }

  // Close download menu when clicking outside
  document.addEventListener('click', function(event) {
    const menu = document.getElementById('monitor-download-menu');
    if (menu && menu.style.display === 'block') {
      const dropdown = document.getElementById('monitor-download-dropdown');
      if (dropdown && !dropdown.contains(event.target)) {
        menu.style.display = 'none';
      }
    }
  });

  function startQueryMonitorPolling() {
    if (queryMonitorPollTimer) clearInterval(queryMonitorPollTimer);

    fetchQueryFeed(); // Immediate fetch
    queryMonitorPollTimer = setInterval(fetchQueryFeed, QUERY_MONITOR_CONFIG.pollInterval);
  }

  function stopQueryMonitorPolling() {
    if (queryMonitorPollTimer) {
      clearInterval(queryMonitorPollTimer);
      queryMonitorPollTimer = null;
    }
  }

  async function fetchQueryFeed() {
    if (!queryMonitorEnabled) return;

    try {
      const response = await fetch(
        `${pgReportsRoot}/query_monitor/feed?limit=${QUERY_MONITOR_CONFIG.maxQueries}&session_id=${currentSessionId || ''}`
      );
      const data = await response.json();

      if (data.success && data.queries) {
        renderQueryFeed(data.queries);
      }
    } catch (error) {
      console.error('Failed to fetch query feed:', error);
    }
  }

  function renderQueryFeed(queries) {
    const feed = document.getElementById('query-feed');

    if (queries.length === 0) {
      feed.innerHTML = '<div class="query-feed-empty">No queries captured yet...</div>';
      queryCount = 0;
      document.getElementById('query-count').textContent = '0';
      return;
    }

    queryCount = queries.length;
    document.getElementById('query-count').textContent = queryCount;

    // Render queries in reverse chronological order
    const html = queries.slice().reverse().map(query => renderQueryItem(query)).join('');
    feed.innerHTML = html;
  }

  function renderQueryItem(query) {
    const duration = query.duration_ms;
    const durationClass = duration < 10 ? 'fast' : duration > 100 ? 'slow' : '';
    const timestamp = new Date(query.timestamp).toLocaleTimeString();
    const queryId = `query-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    let sourceInfo = 'Unknown source';
    if (query.source_location && query.source_location.file) {
      const file = query.source_location.file;
      const line = query.source_location.line;
      sourceInfo = `<a href="#" onclick="openInIDE('${escapeHtml(file)}', ${line}); return false;">
         ${escapeHtml(file)}:${line}
       </a>`;
    }

    // Prepare SQL: collapse to single line and truncate
    const fullSql = query.sql.trim();
    const collapsedSql = fullSql.replace(/\s+/g, ' ').trim();
    const truncatedSql = collapsedSql.length > 100
      ? collapsedSql.substring(0, 100) + '...'
      : collapsedSql;

    return `
      <div class="query-item">
        <div class="query-header">
          <div class="query-meta">
            <span class="query-timestamp">${timestamp}</span>
            <span class="query-duration ${durationClass}">${duration.toFixed(2)}ms</span>
            <span class="query-source">${sourceInfo}</span>
          </div>
          <button class="query-expand-btn" onclick="toggleQueryExpand('${queryId}')" title="Expand/Collapse">
            <span id="${queryId}-icon">‚ñº</span>
          </button>
        </div>
        <div class="query-sql-wrapper">
          <div class="query-sql query-sql-collapsed" id="${queryId}-sql">
            ${escapeHtml(truncatedSql)}
          </div>
          <div class="query-sql query-sql-expanded" id="${queryId}-sql-full" style="display: none;">
            ${escapeHtml(fullSql)}
          </div>
        </div>
      </div>
    `;
  }

  function toggleQueryExpand(queryId) {
    const collapsedEl = document.getElementById(`${queryId}-sql`);
    const expandedEl = document.getElementById(`${queryId}-sql-full`);
    const iconEl = document.getElementById(`${queryId}-icon`);

    if (collapsedEl.style.display === 'none') {
      // Currently expanded, collapse it
      collapsedEl.style.display = 'block';
      expandedEl.style.display = 'none';
      iconEl.textContent = '‚ñº';
    } else {
      // Currently collapsed, expand it
      collapsedEl.style.display = 'none';
      expandedEl.style.display = 'block';
      iconEl.textContent = '‚ñ≤';
    }
  }

  function escapeHtml(text) {
    if (!text) return '';
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function showToast(message, type = 'success') {
    // Simple console log for now - can be enhanced with actual toast UI
    if (type === 'error') {
      console.error(message);
    } else {
      console.log(message);
    }
    // TODO: Implement actual toast notification UI
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', initQueryMonitoring);
  window.addEventListener('beforeunload', () => {
    stopQueryMonitorPolling();
  });
</script>
